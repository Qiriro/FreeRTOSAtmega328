
FreeRTOSAtmega328.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00800100  00000c92  00000d26  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c92  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000638  0080010e  0080010e  00000d34  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d34  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d64  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001a8  00000000  00000000  00000da4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001b19  00000000  00000000  00000f4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007f8  00000000  00000000  00002a65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a1d  00000000  00000000  0000325d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000438  00000000  00000000  00003c7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000009fb  00000000  00000000  000040b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000122b  00000000  00000000  00004aaf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001a0  00000000  00000000  00005cda  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 86 02 	jmp	0x50c	; 0x50c <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e9       	ldi	r30, 0x92	; 146
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 30       	cpi	r26, 0x0E	; 14
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	ae e0       	ldi	r26, 0x0E	; 14
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a6 34       	cpi	r26, 0x46	; 70
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 5d 00 	call	0xba	; 0xba <main>
  9e:	0c 94 47 06 	jmp	0xc8e	; 0xc8e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vBlinkLed>:
}

static void vBlinkLed(void* pvParameters)
{
	// Se the LED_PIN an output
	DDRB |= (1<<LED_PIN);
  a6:	20 9a       	sbi	0x04, 0	; 4
	while(true)
	{
		PORTB ^= (1<<LED_PIN);
  a8:	c1 e0       	ldi	r28, 0x01	; 1
  aa:	85 b1       	in	r24, 0x05	; 5
  ac:	8c 27       	eor	r24, r28
  ae:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(500);
  b0:	84 ef       	ldi	r24, 0xF4	; 244
  b2:	91 e0       	ldi	r25, 0x01	; 1
  b4:	0e 94 67 05 	call	0xace	; 0xace <vTaskDelay>
	}
  b8:	f8 cf       	rjmp	.-16     	; 0xaa <vBlinkLed+0x4>

000000ba <main>:
#include <stdbool.h> // For true and false
static void vBlinkLed(void* pvParameters);
#define LED_TASK_PRIORITY   (tskIDLE_PRIORITY)
#define LED_PIN PB0
int main(void)
{
  ba:	af 92       	push	r10
  bc:	bf 92       	push	r11
  be:	cf 92       	push	r12
  c0:	df 92       	push	r13
  c2:	ef 92       	push	r14
  c4:	ff 92       	push	r15
  c6:	0f 93       	push	r16
  c8:	cf 93       	push	r28
  ca:	df 93       	push	r29
  cc:	00 d0       	rcall	.+0      	; 0xce <main+0x14>
  ce:	cd b7       	in	r28, 0x3d	; 61
  d0:	de b7       	in	r29, 0x3e	; 62
	// Create task.
	xTaskHandle blink_handle;
	xTaskCreate
  d2:	a1 2c       	mov	r10, r1
  d4:	b1 2c       	mov	r11, r1
  d6:	c1 2c       	mov	r12, r1
  d8:	d1 2c       	mov	r13, r1
  da:	ce 01       	movw	r24, r28
  dc:	01 96       	adiw	r24, 0x01	; 1
  de:	7c 01       	movw	r14, r24
  e0:	00 e0       	ldi	r16, 0x00	; 0
  e2:	20 e0       	ldi	r18, 0x00	; 0
  e4:	30 e0       	ldi	r19, 0x00	; 0
  e6:	45 e5       	ldi	r20, 0x55	; 85
  e8:	50 e0       	ldi	r21, 0x00	; 0
  ea:	62 e0       	ldi	r22, 0x02	; 2
  ec:	71 e0       	ldi	r23, 0x01	; 1
  ee:	83 e5       	ldi	r24, 0x53	; 83
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	0e 94 e7 02 	call	0x5ce	; 0x5ce <xTaskGenericCreate>
	LED_TASK_PRIORITY,
	&blink_handle
	);

	// Start scheduler.
	vTaskStartScheduler();
  f6:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <vTaskStartScheduler>

	return 0;
}
  fa:	80 e0       	ldi	r24, 0x00	; 0
  fc:	90 e0       	ldi	r25, 0x00	; 0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	df 91       	pop	r29
 104:	cf 91       	pop	r28
 106:	0f 91       	pop	r16
 108:	ff 90       	pop	r15
 10a:	ef 90       	pop	r14
 10c:	df 90       	pop	r13
 10e:	cf 90       	pop	r12
 110:	bf 90       	pop	r11
 112:	af 90       	pop	r10
 114:	08 95       	ret

00000116 <vApplicationIdleHook>:
It is paramount that the idle hook function does not call any API functions that could cause it to block
Note: You may find it useful to disable this method in the FreeRTOSConfig.h file. To do this,
just set the configUSE_IDLE_HOOK to 0
*/
void vApplicationIdleHook(void)
{
 116:	08 95       	ret

00000118 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 118:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 11a:	03 96       	adiw	r24, 0x03	; 3
 11c:	92 83       	std	Z+2, r25	; 0x02
 11e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 120:	2f ef       	ldi	r18, 0xFF	; 255
 122:	3f ef       	ldi	r19, 0xFF	; 255
 124:	34 83       	std	Z+4, r19	; 0x04
 126:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 128:	96 83       	std	Z+6, r25	; 0x06
 12a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 12c:	90 87       	std	Z+8, r25	; 0x08
 12e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 130:	10 82       	st	Z, r1
 132:	08 95       	ret

00000134 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 134:	fc 01       	movw	r30, r24
 136:	11 86       	std	Z+9, r1	; 0x09
 138:	10 86       	std	Z+8, r1	; 0x08
 13a:	08 95       	ret

0000013c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 13c:	cf 93       	push	r28
 13e:	df 93       	push	r29
 140:	fc 01       	movw	r30, r24
 142:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 144:	21 81       	ldd	r18, Z+1	; 0x01
 146:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 148:	e9 01       	movw	r28, r18
 14a:	8a 81       	ldd	r24, Y+2	; 0x02
 14c:	9b 81       	ldd	r25, Y+3	; 0x03
 14e:	13 96       	adiw	r26, 0x03	; 3
 150:	9c 93       	st	X, r25
 152:	8e 93       	st	-X, r24
 154:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 156:	81 81       	ldd	r24, Z+1	; 0x01
 158:	92 81       	ldd	r25, Z+2	; 0x02
 15a:	15 96       	adiw	r26, 0x05	; 5
 15c:	9c 93       	st	X, r25
 15e:	8e 93       	st	-X, r24
 160:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 162:	8a 81       	ldd	r24, Y+2	; 0x02
 164:	9b 81       	ldd	r25, Y+3	; 0x03
 166:	ec 01       	movw	r28, r24
 168:	7d 83       	std	Y+5, r23	; 0x05
 16a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 16c:	e9 01       	movw	r28, r18
 16e:	7b 83       	std	Y+3, r23	; 0x03
 170:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 172:	72 83       	std	Z+2, r23	; 0x02
 174:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 176:	19 96       	adiw	r26, 0x09	; 9
 178:	fc 93       	st	X, r31
 17a:	ee 93       	st	-X, r30
 17c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 17e:	80 81       	ld	r24, Z
 180:	8f 5f       	subi	r24, 0xFF	; 255
 182:	80 83       	st	Z, r24
}
 184:	df 91       	pop	r29
 186:	cf 91       	pop	r28
 188:	08 95       	ret

0000018a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 18a:	cf 93       	push	r28
 18c:	df 93       	push	r29
 18e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 190:	48 81       	ld	r20, Y
 192:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 194:	4f 3f       	cpi	r20, 0xFF	; 255
 196:	2f ef       	ldi	r18, 0xFF	; 255
 198:	52 07       	cpc	r21, r18
 19a:	31 f4       	brne	.+12     	; 0x1a8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 19c:	dc 01       	movw	r26, r24
 19e:	17 96       	adiw	r26, 0x07	; 7
 1a0:	ed 91       	ld	r30, X+
 1a2:	fc 91       	ld	r31, X
 1a4:	18 97       	sbiw	r26, 0x08	; 8
 1a6:	17 c0       	rjmp	.+46     	; 0x1d6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1a8:	fc 01       	movw	r30, r24
 1aa:	33 96       	adiw	r30, 0x03	; 3
 1ac:	dc 01       	movw	r26, r24
 1ae:	15 96       	adiw	r26, 0x05	; 5
 1b0:	2d 91       	ld	r18, X+
 1b2:	3c 91       	ld	r19, X
 1b4:	16 97       	sbiw	r26, 0x06	; 6
 1b6:	d9 01       	movw	r26, r18
 1b8:	2d 91       	ld	r18, X+
 1ba:	3c 91       	ld	r19, X
 1bc:	42 17       	cp	r20, r18
 1be:	53 07       	cpc	r21, r19
 1c0:	50 f0       	brcs	.+20     	; 0x1d6 <vListInsert+0x4c>
 1c2:	02 80       	ldd	r0, Z+2	; 0x02
 1c4:	f3 81       	ldd	r31, Z+3	; 0x03
 1c6:	e0 2d       	mov	r30, r0
 1c8:	a2 81       	ldd	r26, Z+2	; 0x02
 1ca:	b3 81       	ldd	r27, Z+3	; 0x03
 1cc:	2d 91       	ld	r18, X+
 1ce:	3c 91       	ld	r19, X
 1d0:	42 17       	cp	r20, r18
 1d2:	53 07       	cpc	r21, r19
 1d4:	b0 f7       	brcc	.-20     	; 0x1c2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1d6:	a2 81       	ldd	r26, Z+2	; 0x02
 1d8:	b3 81       	ldd	r27, Z+3	; 0x03
 1da:	bb 83       	std	Y+3, r27	; 0x03
 1dc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 1de:	15 96       	adiw	r26, 0x05	; 5
 1e0:	dc 93       	st	X, r29
 1e2:	ce 93       	st	-X, r28
 1e4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 1e6:	fd 83       	std	Y+5, r31	; 0x05
 1e8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 1ea:	d3 83       	std	Z+3, r29	; 0x03
 1ec:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1ee:	99 87       	std	Y+9, r25	; 0x09
 1f0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1f2:	fc 01       	movw	r30, r24
 1f4:	20 81       	ld	r18, Z
 1f6:	2f 5f       	subi	r18, 0xFF	; 255
 1f8:	20 83       	st	Z, r18
}
 1fa:	df 91       	pop	r29
 1fc:	cf 91       	pop	r28
 1fe:	08 95       	ret

00000200 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 200:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 202:	a2 81       	ldd	r26, Z+2	; 0x02
 204:	b3 81       	ldd	r27, Z+3	; 0x03
 206:	84 81       	ldd	r24, Z+4	; 0x04
 208:	95 81       	ldd	r25, Z+5	; 0x05
 20a:	15 96       	adiw	r26, 0x05	; 5
 20c:	9c 93       	st	X, r25
 20e:	8e 93       	st	-X, r24
 210:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 212:	a4 81       	ldd	r26, Z+4	; 0x04
 214:	b5 81       	ldd	r27, Z+5	; 0x05
 216:	82 81       	ldd	r24, Z+2	; 0x02
 218:	93 81       	ldd	r25, Z+3	; 0x03
 21a:	13 96       	adiw	r26, 0x03	; 3
 21c:	9c 93       	st	X, r25
 21e:	8e 93       	st	-X, r24
 220:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 222:	a0 85       	ldd	r26, Z+8	; 0x08
 224:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 226:	11 96       	adiw	r26, 0x01	; 1
 228:	8d 91       	ld	r24, X+
 22a:	9c 91       	ld	r25, X
 22c:	12 97       	sbiw	r26, 0x02	; 2
 22e:	8e 17       	cp	r24, r30
 230:	9f 07       	cpc	r25, r31
 232:	31 f4       	brne	.+12     	; 0x240 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 234:	84 81       	ldd	r24, Z+4	; 0x04
 236:	95 81       	ldd	r25, Z+5	; 0x05
 238:	12 96       	adiw	r26, 0x02	; 2
 23a:	9c 93       	st	X, r25
 23c:	8e 93       	st	-X, r24
 23e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 240:	11 86       	std	Z+9, r1	; 0x09
 242:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 244:	8c 91       	ld	r24, X
 246:	81 50       	subi	r24, 0x01	; 1
 248:	8c 93       	st	X, r24
 24a:	08 95       	ret

0000024c <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 24c:	31 e1       	ldi	r19, 0x11	; 17
 24e:	fc 01       	movw	r30, r24
 250:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 252:	31 97       	sbiw	r30, 0x01	; 1
 254:	22 e2       	ldi	r18, 0x22	; 34
 256:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 258:	31 97       	sbiw	r30, 0x01	; 1
 25a:	a3 e3       	ldi	r26, 0x33	; 51
 25c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 25e:	31 97       	sbiw	r30, 0x01	; 1
 260:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
 266:	31 97       	sbiw	r30, 0x01	; 1
 268:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 26a:	31 97       	sbiw	r30, 0x01	; 1
 26c:	60 e8       	ldi	r22, 0x80	; 128
 26e:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
 270:	31 97       	sbiw	r30, 0x01	; 1
 272:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	62 e0       	ldi	r22, 0x02	; 2
 278:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	63 e0       	ldi	r22, 0x03	; 3
 27e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	64 e0       	ldi	r22, 0x04	; 4
 284:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
 286:	31 97       	sbiw	r30, 0x01	; 1
 288:	65 e0       	ldi	r22, 0x05	; 5
 28a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
 28c:	31 97       	sbiw	r30, 0x01	; 1
 28e:	66 e0       	ldi	r22, 0x06	; 6
 290:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
 292:	31 97       	sbiw	r30, 0x01	; 1
 294:	67 e0       	ldi	r22, 0x07	; 7
 296:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
 298:	31 97       	sbiw	r30, 0x01	; 1
 29a:	68 e0       	ldi	r22, 0x08	; 8
 29c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
 29e:	31 97       	sbiw	r30, 0x01	; 1
 2a0:	69 e0       	ldi	r22, 0x09	; 9
 2a2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
 2a4:	31 97       	sbiw	r30, 0x01	; 1
 2a6:	60 e1       	ldi	r22, 0x10	; 16
 2a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
 2aa:	31 97       	sbiw	r30, 0x01	; 1
 2ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	32 e1       	ldi	r19, 0x12	; 18
 2b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	33 e1       	ldi	r19, 0x13	; 19
 2b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	34 e1       	ldi	r19, 0x14	; 20
 2be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
 2c0:	31 97       	sbiw	r30, 0x01	; 1
 2c2:	35 e1       	ldi	r19, 0x15	; 21
 2c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	36 e1       	ldi	r19, 0x16	; 22
 2ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	37 e1       	ldi	r19, 0x17	; 23
 2d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	38 e1       	ldi	r19, 0x18	; 24
 2d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
 2d8:	31 97       	sbiw	r30, 0x01	; 1
 2da:	39 e1       	ldi	r19, 0x19	; 25
 2dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	30 e2       	ldi	r19, 0x20	; 32
 2e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	31 e2       	ldi	r19, 0x21	; 33
 2e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
 2ee:	31 97       	sbiw	r30, 0x01	; 1
 2f0:	23 e2       	ldi	r18, 0x23	; 35
 2f2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 2f4:	31 97       	sbiw	r30, 0x01	; 1
 2f6:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	26 e2       	ldi	r18, 0x26	; 38
 300:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	27 e2       	ldi	r18, 0x27	; 39
 306:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	28 e2       	ldi	r18, 0x28	; 40
 30c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
 30e:	31 97       	sbiw	r30, 0x01	; 1
 310:	29 e2       	ldi	r18, 0x29	; 41
 312:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
 314:	31 97       	sbiw	r30, 0x01	; 1
 316:	20 e3       	ldi	r18, 0x30	; 48
 318:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
 31a:	31 97       	sbiw	r30, 0x01	; 1
 31c:	21 e3       	ldi	r18, 0x31	; 49
 31e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 320:	86 97       	sbiw	r24, 0x26	; 38
 322:	08 95       	ret

00000324 <xPortStartScheduler>:
    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned long ) 1;

    /* Setup compare match value for compare match A.  Interrupts are disabled
    before this is called so we need not worry here. */
    OCR1A = ulCompareMatch;
 324:	8e e0       	ldi	r24, 0x0E	; 14
 326:	90 e0       	ldi	r25, 0x00	; 0
 328:	90 93 89 00 	sts	0x0089, r25
 32c:	80 93 88 00 	sts	0x0088, r24

    /* Setup clock source and compare match behaviour. */
    TCCR1A &= ~(_BV(WGM11) | _BV(WGM10));
 330:	e0 e8       	ldi	r30, 0x80	; 128
 332:	f0 e0       	ldi	r31, 0x00	; 0
 334:	80 81       	ld	r24, Z
 336:	8c 7f       	andi	r24, 0xFC	; 252
 338:	80 83       	st	Z, r24
    ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    TCCR1B = ucLowByte;
 33a:	8b e0       	ldi	r24, 0x0B	; 11
 33c:	80 93 81 00 	sts	0x0081, r24

    /* Enable the interrupt - this is okay as interrupt are currently globally
    disabled. */
    ucLowByte = TIMSK1;
 340:	ef e6       	ldi	r30, 0x6F	; 111
 342:	f0 e0       	ldi	r31, 0x00	; 0
 344:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 346:	82 60       	ori	r24, 0x02	; 2
    TIMSK1 = ucLowByte;
 348:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 34a:	a0 91 44 07 	lds	r26, 0x0744
 34e:	b0 91 45 07 	lds	r27, 0x0745
 352:	cd 91       	ld	r28, X+
 354:	cd bf       	out	0x3d, r28	; 61
 356:	dd 91       	ld	r29, X+
 358:	de bf       	out	0x3e, r29	; 62
 35a:	ff 91       	pop	r31
 35c:	ef 91       	pop	r30
 35e:	df 91       	pop	r29
 360:	cf 91       	pop	r28
 362:	bf 91       	pop	r27
 364:	af 91       	pop	r26
 366:	9f 91       	pop	r25
 368:	8f 91       	pop	r24
 36a:	7f 91       	pop	r23
 36c:	6f 91       	pop	r22
 36e:	5f 91       	pop	r21
 370:	4f 91       	pop	r20
 372:	3f 91       	pop	r19
 374:	2f 91       	pop	r18
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	ff 90       	pop	r15
 37c:	ef 90       	pop	r14
 37e:	df 90       	pop	r13
 380:	cf 90       	pop	r12
 382:	bf 90       	pop	r11
 384:	af 90       	pop	r10
 386:	9f 90       	pop	r9
 388:	8f 90       	pop	r8
 38a:	7f 90       	pop	r7
 38c:	6f 90       	pop	r6
 38e:	5f 90       	pop	r5
 390:	4f 90       	pop	r4
 392:	3f 90       	pop	r3
 394:	2f 90       	pop	r2
 396:	1f 90       	pop	r1
 398:	0f 90       	pop	r0
 39a:	0f be       	out	0x3f, r0	; 63
 39c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 39e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	08 95       	ret

000003a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3a4:	0f 92       	push	r0
 3a6:	0f b6       	in	r0, 0x3f	; 63
 3a8:	f8 94       	cli
 3aa:	0f 92       	push	r0
 3ac:	1f 92       	push	r1
 3ae:	11 24       	eor	r1, r1
 3b0:	2f 92       	push	r2
 3b2:	3f 92       	push	r3
 3b4:	4f 92       	push	r4
 3b6:	5f 92       	push	r5
 3b8:	6f 92       	push	r6
 3ba:	7f 92       	push	r7
 3bc:	8f 92       	push	r8
 3be:	9f 92       	push	r9
 3c0:	af 92       	push	r10
 3c2:	bf 92       	push	r11
 3c4:	cf 92       	push	r12
 3c6:	df 92       	push	r13
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	2f 93       	push	r18
 3d2:	3f 93       	push	r19
 3d4:	4f 93       	push	r20
 3d6:	5f 93       	push	r21
 3d8:	6f 93       	push	r22
 3da:	7f 93       	push	r23
 3dc:	8f 93       	push	r24
 3de:	9f 93       	push	r25
 3e0:	af 93       	push	r26
 3e2:	bf 93       	push	r27
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	ef 93       	push	r30
 3ea:	ff 93       	push	r31
 3ec:	a0 91 44 07 	lds	r26, 0x0744
 3f0:	b0 91 45 07 	lds	r27, 0x0745
 3f4:	0d b6       	in	r0, 0x3d	; 61
 3f6:	0d 92       	st	X+, r0
 3f8:	0e b6       	in	r0, 0x3e	; 62
 3fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3fc:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 400:	a0 91 44 07 	lds	r26, 0x0744
 404:	b0 91 45 07 	lds	r27, 0x0745
 408:	cd 91       	ld	r28, X+
 40a:	cd bf       	out	0x3d, r28	; 61
 40c:	dd 91       	ld	r29, X+
 40e:	de bf       	out	0x3e, r29	; 62
 410:	ff 91       	pop	r31
 412:	ef 91       	pop	r30
 414:	df 91       	pop	r29
 416:	cf 91       	pop	r28
 418:	bf 91       	pop	r27
 41a:	af 91       	pop	r26
 41c:	9f 91       	pop	r25
 41e:	8f 91       	pop	r24
 420:	7f 91       	pop	r23
 422:	6f 91       	pop	r22
 424:	5f 91       	pop	r21
 426:	4f 91       	pop	r20
 428:	3f 91       	pop	r19
 42a:	2f 91       	pop	r18
 42c:	1f 91       	pop	r17
 42e:	0f 91       	pop	r16
 430:	ff 90       	pop	r15
 432:	ef 90       	pop	r14
 434:	df 90       	pop	r13
 436:	cf 90       	pop	r12
 438:	bf 90       	pop	r11
 43a:	af 90       	pop	r10
 43c:	9f 90       	pop	r9
 43e:	8f 90       	pop	r8
 440:	7f 90       	pop	r7
 442:	6f 90       	pop	r6
 444:	5f 90       	pop	r5
 446:	4f 90       	pop	r4
 448:	3f 90       	pop	r3
 44a:	2f 90       	pop	r2
 44c:	1f 90       	pop	r1
 44e:	0f 90       	pop	r0
 450:	0f be       	out	0x3f, r0	; 63
 452:	0f 90       	pop	r0

	asm volatile ( "ret" );
 454:	08 95       	ret

00000456 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 456:	0f 92       	push	r0
 458:	0f b6       	in	r0, 0x3f	; 63
 45a:	f8 94       	cli
 45c:	0f 92       	push	r0
 45e:	1f 92       	push	r1
 460:	11 24       	eor	r1, r1
 462:	2f 92       	push	r2
 464:	3f 92       	push	r3
 466:	4f 92       	push	r4
 468:	5f 92       	push	r5
 46a:	6f 92       	push	r6
 46c:	7f 92       	push	r7
 46e:	8f 92       	push	r8
 470:	9f 92       	push	r9
 472:	af 92       	push	r10
 474:	bf 92       	push	r11
 476:	cf 92       	push	r12
 478:	df 92       	push	r13
 47a:	ef 92       	push	r14
 47c:	ff 92       	push	r15
 47e:	0f 93       	push	r16
 480:	1f 93       	push	r17
 482:	2f 93       	push	r18
 484:	3f 93       	push	r19
 486:	4f 93       	push	r20
 488:	5f 93       	push	r21
 48a:	6f 93       	push	r22
 48c:	7f 93       	push	r23
 48e:	8f 93       	push	r24
 490:	9f 93       	push	r25
 492:	af 93       	push	r26
 494:	bf 93       	push	r27
 496:	cf 93       	push	r28
 498:	df 93       	push	r29
 49a:	ef 93       	push	r30
 49c:	ff 93       	push	r31
 49e:	a0 91 44 07 	lds	r26, 0x0744
 4a2:	b0 91 45 07 	lds	r27, 0x0745
 4a6:	0d b6       	in	r0, 0x3d	; 61
 4a8:	0d 92       	st	X+, r0
 4aa:	0e b6       	in	r0, 0x3e	; 62
 4ac:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 4ae:	0e 94 1d 04 	call	0x83a	; 0x83a <vTaskIncrementTick>
	vTaskSwitchContext();
 4b2:	0e 94 c5 05 	call	0xb8a	; 0xb8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4b6:	a0 91 44 07 	lds	r26, 0x0744
 4ba:	b0 91 45 07 	lds	r27, 0x0745
 4be:	cd 91       	ld	r28, X+
 4c0:	cd bf       	out	0x3d, r28	; 61
 4c2:	dd 91       	ld	r29, X+
 4c4:	de bf       	out	0x3e, r29	; 62
 4c6:	ff 91       	pop	r31
 4c8:	ef 91       	pop	r30
 4ca:	df 91       	pop	r29
 4cc:	cf 91       	pop	r28
 4ce:	bf 91       	pop	r27
 4d0:	af 91       	pop	r26
 4d2:	9f 91       	pop	r25
 4d4:	8f 91       	pop	r24
 4d6:	7f 91       	pop	r23
 4d8:	6f 91       	pop	r22
 4da:	5f 91       	pop	r21
 4dc:	4f 91       	pop	r20
 4de:	3f 91       	pop	r19
 4e0:	2f 91       	pop	r18
 4e2:	1f 91       	pop	r17
 4e4:	0f 91       	pop	r16
 4e6:	ff 90       	pop	r15
 4e8:	ef 90       	pop	r14
 4ea:	df 90       	pop	r13
 4ec:	cf 90       	pop	r12
 4ee:	bf 90       	pop	r11
 4f0:	af 90       	pop	r10
 4f2:	9f 90       	pop	r9
 4f4:	8f 90       	pop	r8
 4f6:	7f 90       	pop	r7
 4f8:	6f 90       	pop	r6
 4fa:	5f 90       	pop	r5
 4fc:	4f 90       	pop	r4
 4fe:	3f 90       	pop	r3
 500:	2f 90       	pop	r2
 502:	1f 90       	pop	r1
 504:	0f 90       	pop	r0
 506:	0f be       	out	0x3f, r0	; 63
 508:	0f 90       	pop	r0

	asm volatile ( "ret" );
 50a:	08 95       	ret

0000050c <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 50c:	0e 94 2b 02 	call	0x456	; 0x456 <vPortYieldFromTick>
		asm volatile ( "reti" );
 510:	18 95       	reti

00000512 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 512:	cf 93       	push	r28
 514:	df 93       	push	r29
 516:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 518:	0e 94 17 04 	call	0x82e	; 0x82e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 51c:	20 91 0e 01 	lds	r18, 0x010E
 520:	30 91 0f 01 	lds	r19, 0x010F
 524:	ce 01       	movw	r24, r28
 526:	82 0f       	add	r24, r18
 528:	93 1f       	adc	r25, r19
 52a:	8c 3d       	cpi	r24, 0xDC	; 220
 52c:	45 e0       	ldi	r20, 0x05	; 5
 52e:	94 07       	cpc	r25, r20
 530:	58 f4       	brcc	.+22     	; 0x548 <pvPortMalloc+0x36>
 532:	28 17       	cp	r18, r24
 534:	39 07       	cpc	r19, r25
 536:	58 f4       	brcc	.+22     	; 0x54e <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 538:	e9 01       	movw	r28, r18
 53a:	c0 5f       	subi	r28, 0xF0	; 240
 53c:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
 53e:	90 93 0f 01 	sts	0x010F, r25
 542:	80 93 0e 01 	sts	0x010E, r24
 546:	05 c0       	rjmp	.+10     	; 0x552 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 548:	c0 e0       	ldi	r28, 0x00	; 0
 54a:	d0 e0       	ldi	r29, 0x00	; 0
 54c:	02 c0       	rjmp	.+4      	; 0x552 <pvPortMalloc+0x40>
 54e:	c0 e0       	ldi	r28, 0x00	; 0
 550:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 552:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 556:	ce 01       	movw	r24, r28
 558:	df 91       	pop	r29
 55a:	cf 91       	pop	r28
 55c:	08 95       	ret

0000055e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 55e:	08 95       	ret

00000560 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 560:	cf 93       	push	r28
 562:	df 93       	push	r29
 564:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 566:	e0 91 44 07 	lds	r30, 0x0744
 56a:	f0 91 45 07 	lds	r31, 0x0745
 56e:	93 83       	std	Z+3, r25	; 0x03
 570:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 572:	80 91 f4 06 	lds	r24, 0x06F4
 576:	90 91 f5 06 	lds	r25, 0x06F5
 57a:	c8 17       	cp	r28, r24
 57c:	d9 07       	cpc	r29, r25
 57e:	68 f4       	brcc	.+26     	; 0x59a <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 580:	60 91 44 07 	lds	r22, 0x0744
 584:	70 91 45 07 	lds	r23, 0x0745
 588:	80 91 0a 07 	lds	r24, 0x070A
 58c:	90 91 0b 07 	lds	r25, 0x070B
 590:	6e 5f       	subi	r22, 0xFE	; 254
 592:	7f 4f       	sbci	r23, 0xFF	; 255
 594:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInsert>
 598:	17 c0       	rjmp	.+46     	; 0x5c8 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 59a:	60 91 44 07 	lds	r22, 0x0744
 59e:	70 91 45 07 	lds	r23, 0x0745
 5a2:	80 91 0c 07 	lds	r24, 0x070C
 5a6:	90 91 0d 07 	lds	r25, 0x070D
 5aa:	6e 5f       	subi	r22, 0xFE	; 254
 5ac:	7f 4f       	sbci	r23, 0xFF	; 255
 5ae:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 5b2:	80 91 00 01 	lds	r24, 0x0100
 5b6:	90 91 01 01 	lds	r25, 0x0101
 5ba:	c8 17       	cp	r28, r24
 5bc:	d9 07       	cpc	r29, r25
 5be:	20 f4       	brcc	.+8      	; 0x5c8 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
 5c0:	d0 93 01 01 	sts	0x0101, r29
 5c4:	c0 93 00 01 	sts	0x0100, r28
		}
	}
}
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	08 95       	ret

000005ce <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 5ce:	4f 92       	push	r4
 5d0:	5f 92       	push	r5
 5d2:	6f 92       	push	r6
 5d4:	7f 92       	push	r7
 5d6:	8f 92       	push	r8
 5d8:	9f 92       	push	r9
 5da:	af 92       	push	r10
 5dc:	bf 92       	push	r11
 5de:	cf 92       	push	r12
 5e0:	df 92       	push	r13
 5e2:	ef 92       	push	r14
 5e4:	ff 92       	push	r15
 5e6:	0f 93       	push	r16
 5e8:	1f 93       	push	r17
 5ea:	cf 93       	push	r28
 5ec:	df 93       	push	r29
 5ee:	5c 01       	movw	r10, r24
 5f0:	4b 01       	movw	r8, r22
 5f2:	3a 01       	movw	r6, r20
 5f4:	29 01       	movw	r4, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 5f6:	81 e2       	ldi	r24, 0x21	; 33
 5f8:	90 e0       	ldi	r25, 0x00	; 0
 5fa:	0e 94 89 02 	call	0x512	; 0x512 <pvPortMalloc>
 5fe:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
 600:	89 2b       	or	r24, r25
 602:	09 f4       	brne	.+2      	; 0x606 <xTaskGenericCreate+0x38>
 604:	d7 c0       	rjmp	.+430    	; 0x7b4 <xTaskGenericCreate+0x1e6>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 606:	c1 14       	cp	r12, r1
 608:	d1 04       	cpc	r13, r1
 60a:	09 f0       	breq	.+2      	; 0x60e <xTaskGenericCreate+0x40>
 60c:	cf c0       	rjmp	.+414    	; 0x7ac <xTaskGenericCreate+0x1de>
 60e:	c3 01       	movw	r24, r6
 610:	0e 94 89 02 	call	0x512	; 0x512 <pvPortMalloc>
 614:	98 8f       	std	Y+24, r25	; 0x18
 616:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
 618:	00 97       	sbiw	r24, 0x00	; 0
 61a:	21 f4       	brne	.+8      	; 0x624 <xTaskGenericCreate+0x56>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 61c:	ce 01       	movw	r24, r28
 61e:	0e 94 af 02 	call	0x55e	; 0x55e <vPortFree>
 622:	c8 c0       	rjmp	.+400    	; 0x7b4 <xTaskGenericCreate+0x1e6>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 624:	a3 01       	movw	r20, r6
 626:	65 ea       	ldi	r22, 0xA5	; 165
 628:	70 e0       	ldi	r23, 0x00	; 0
 62a:	0e 94 31 06 	call	0xc62	; 0xc62 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 62e:	93 01       	movw	r18, r6
 630:	21 50       	subi	r18, 0x01	; 1
 632:	31 09       	sbc	r19, r1
 634:	8f 89       	ldd	r24, Y+23	; 0x17
 636:	98 8d       	ldd	r25, Y+24	; 0x18
 638:	3c 01       	movw	r6, r24
 63a:	62 0e       	add	r6, r18
 63c:	73 1e       	adc	r7, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 63e:	48 e0       	ldi	r20, 0x08	; 8
 640:	50 e0       	ldi	r21, 0x00	; 0
 642:	b4 01       	movw	r22, r8
 644:	ce 01       	movw	r24, r28
 646:	49 96       	adiw	r24, 0x19	; 25
 648:	0e 94 38 06 	call	0xc70	; 0xc70 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 64c:	18 a2       	std	Y+32, r1	; 0x20
 64e:	10 2f       	mov	r17, r16
 650:	04 30       	cpi	r16, 0x04	; 4
 652:	08 f0       	brcs	.+2      	; 0x656 <xTaskGenericCreate+0x88>
 654:	13 e0       	ldi	r17, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 656:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 658:	6e 01       	movw	r12, r28
 65a:	82 e0       	ldi	r24, 0x02	; 2
 65c:	c8 0e       	add	r12, r24
 65e:	d1 1c       	adc	r13, r1
 660:	c6 01       	movw	r24, r12
 662:	0e 94 9a 00 	call	0x134	; 0x134 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 666:	ce 01       	movw	r24, r28
 668:	0c 96       	adiw	r24, 0x0c	; 12
 66a:	0e 94 9a 00 	call	0x134	; 0x134 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 66e:	d9 87       	std	Y+9, r29	; 0x09
 670:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 672:	84 e0       	ldi	r24, 0x04	; 4
 674:	90 e0       	ldi	r25, 0x00	; 0
 676:	81 1b       	sub	r24, r17
 678:	91 09       	sbc	r25, r1
 67a:	9d 87       	std	Y+13, r25	; 0x0d
 67c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 67e:	db 8b       	std	Y+19, r29	; 0x13
 680:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 682:	a2 01       	movw	r20, r4
 684:	b5 01       	movw	r22, r10
 686:	c3 01       	movw	r24, r6
 688:	0e 94 26 01 	call	0x24c	; 0x24c <pxPortInitialiseStack>
 68c:	99 83       	std	Y+1, r25	; 0x01
 68e:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
 690:	e1 14       	cp	r14, r1
 692:	f1 04       	cpc	r15, r1
 694:	19 f0       	breq	.+6      	; 0x69c <xTaskGenericCreate+0xce>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 696:	f7 01       	movw	r30, r14
 698:	d1 83       	std	Z+1, r29	; 0x01
 69a:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 69c:	0f b6       	in	r0, 0x3f	; 63
 69e:	f8 94       	cli
 6a0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 6a2:	80 91 f6 06 	lds	r24, 0x06F6
 6a6:	8f 5f       	subi	r24, 0xFF	; 255
 6a8:	80 93 f6 06 	sts	0x06F6, r24
			if( pxCurrentTCB == NULL )
 6ac:	80 91 44 07 	lds	r24, 0x0744
 6b0:	90 91 45 07 	lds	r25, 0x0745
 6b4:	89 2b       	or	r24, r25
 6b6:	a9 f5       	brne	.+106    	; 0x722 <xTaskGenericCreate+0x154>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 6b8:	d0 93 45 07 	sts	0x0745, r29
 6bc:	c0 93 44 07 	sts	0x0744, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 6c0:	80 91 f6 06 	lds	r24, 0x06F6
 6c4:	81 30       	cpi	r24, 0x01	; 1
 6c6:	e1 f5       	brne	.+120    	; 0x740 <xTaskGenericCreate+0x172>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 6c8:	80 e2       	ldi	r24, 0x20	; 32
 6ca:	97 e0       	ldi	r25, 0x07	; 7
 6cc:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
 6d0:	89 e2       	ldi	r24, 0x29	; 41
 6d2:	97 e0       	ldi	r25, 0x07	; 7
 6d4:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
 6d8:	82 e3       	ldi	r24, 0x32	; 50
 6da:	97 e0       	ldi	r25, 0x07	; 7
 6dc:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
 6e0:	8b e3       	ldi	r24, 0x3B	; 59
 6e2:	97 e0       	ldi	r25, 0x07	; 7
 6e4:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 6e8:	87 e1       	ldi	r24, 0x17	; 23
 6ea:	97 e0       	ldi	r25, 0x07	; 7
 6ec:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 6f0:	8e e0       	ldi	r24, 0x0E	; 14
 6f2:	97 e0       	ldi	r25, 0x07	; 7
 6f4:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 6f8:	81 e0       	ldi	r24, 0x01	; 1
 6fa:	97 e0       	ldi	r25, 0x07	; 7
 6fc:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 700:	88 ef       	ldi	r24, 0xF8	; 248
 702:	96 e0       	ldi	r25, 0x06	; 6
 704:	0e 94 8c 00 	call	0x118	; 0x118 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 708:	87 e1       	ldi	r24, 0x17	; 23
 70a:	97 e0       	ldi	r25, 0x07	; 7
 70c:	90 93 0d 07 	sts	0x070D, r25
 710:	80 93 0c 07 	sts	0x070C, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 714:	8e e0       	ldi	r24, 0x0E	; 14
 716:	97 e0       	ldi	r25, 0x07	; 7
 718:	90 93 0b 07 	sts	0x070B, r25
 71c:	80 93 0a 07 	sts	0x070A, r24
 720:	0f c0       	rjmp	.+30     	; 0x740 <xTaskGenericCreate+0x172>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 722:	80 91 f1 06 	lds	r24, 0x06F1
 726:	81 11       	cpse	r24, r1
 728:	0b c0       	rjmp	.+22     	; 0x740 <xTaskGenericCreate+0x172>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 72a:	e0 91 44 07 	lds	r30, 0x0744
 72e:	f0 91 45 07 	lds	r31, 0x0745
 732:	86 89       	ldd	r24, Z+22	; 0x16
 734:	08 17       	cp	r16, r24
 736:	20 f0       	brcs	.+8      	; 0x740 <xTaskGenericCreate+0x172>
					{
						pxCurrentTCB = pxNewTCB;
 738:	d0 93 45 07 	sts	0x0745, r29
 73c:	c0 93 44 07 	sts	0x0744, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 740:	8e 89       	ldd	r24, Y+22	; 0x16
 742:	90 91 f3 06 	lds	r25, 0x06F3
 746:	98 17       	cp	r25, r24
 748:	10 f4       	brcc	.+4      	; 0x74e <xTaskGenericCreate+0x180>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 74a:	80 93 f3 06 	sts	0x06F3, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTCBNumber;
			}
			#endif
			uxTCBNumber++;
 74e:	90 91 ec 06 	lds	r25, 0x06EC
 752:	9f 5f       	subi	r25, 0xFF	; 255
 754:	90 93 ec 06 	sts	0x06EC, r25

			prvAddTaskToReadyQueue( pxNewTCB );
 758:	90 91 f2 06 	lds	r25, 0x06F2
 75c:	98 17       	cp	r25, r24
 75e:	10 f4       	brcc	.+4      	; 0x764 <xTaskGenericCreate+0x196>
 760:	80 93 f2 06 	sts	0x06F2, r24
 764:	90 e0       	ldi	r25, 0x00	; 0
 766:	9c 01       	movw	r18, r24
 768:	22 0f       	add	r18, r18
 76a:	33 1f       	adc	r19, r19
 76c:	22 0f       	add	r18, r18
 76e:	33 1f       	adc	r19, r19
 770:	22 0f       	add	r18, r18
 772:	33 1f       	adc	r19, r19
 774:	82 0f       	add	r24, r18
 776:	93 1f       	adc	r25, r19
 778:	b6 01       	movw	r22, r12
 77a:	80 5e       	subi	r24, 0xE0	; 224
 77c:	98 4f       	sbci	r25, 0xF8	; 248
 77e:	0e 94 9e 00 	call	0x13c	; 0x13c <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 782:	0f 90       	pop	r0
 784:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 786:	80 91 f1 06 	lds	r24, 0x06F1
 78a:	88 23       	and	r24, r24
 78c:	59 f0       	breq	.+22     	; 0x7a4 <xTaskGenericCreate+0x1d6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 78e:	e0 91 44 07 	lds	r30, 0x0744
 792:	f0 91 45 07 	lds	r31, 0x0745
 796:	86 89       	ldd	r24, Z+22	; 0x16
 798:	80 17       	cp	r24, r16
 79a:	30 f4       	brcc	.+12     	; 0x7a8 <xTaskGenericCreate+0x1da>
			{
				portYIELD_WITHIN_API();
 79c:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
 7a0:	81 e0       	ldi	r24, 0x01	; 1
 7a2:	09 c0       	rjmp	.+18     	; 0x7b6 <xTaskGenericCreate+0x1e8>
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	07 c0       	rjmp	.+14     	; 0x7b6 <xTaskGenericCreate+0x1e8>
 7a8:	81 e0       	ldi	r24, 0x01	; 1
 7aa:	05 c0       	rjmp	.+10     	; 0x7b6 <xTaskGenericCreate+0x1e8>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 7ac:	d8 8e       	std	Y+24, r13	; 0x18
 7ae:	cf 8a       	std	Y+23, r12	; 0x17
 7b0:	c6 01       	movw	r24, r12
 7b2:	38 cf       	rjmp	.-400    	; 0x624 <xTaskGenericCreate+0x56>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 7b4:	8f ef       	ldi	r24, 0xFF	; 255
			}
		}
	}

	return xReturn;
}
 7b6:	df 91       	pop	r29
 7b8:	cf 91       	pop	r28
 7ba:	1f 91       	pop	r17
 7bc:	0f 91       	pop	r16
 7be:	ff 90       	pop	r15
 7c0:	ef 90       	pop	r14
 7c2:	df 90       	pop	r13
 7c4:	cf 90       	pop	r12
 7c6:	bf 90       	pop	r11
 7c8:	af 90       	pop	r10
 7ca:	9f 90       	pop	r9
 7cc:	8f 90       	pop	r8
 7ce:	7f 90       	pop	r7
 7d0:	6f 90       	pop	r6
 7d2:	5f 90       	pop	r5
 7d4:	4f 90       	pop	r4
 7d6:	08 95       	ret

000007d8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 7d8:	af 92       	push	r10
 7da:	bf 92       	push	r11
 7dc:	cf 92       	push	r12
 7de:	df 92       	push	r13
 7e0:	ef 92       	push	r14
 7e2:	ff 92       	push	r15
 7e4:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 7e6:	a1 2c       	mov	r10, r1
 7e8:	b1 2c       	mov	r11, r1
 7ea:	c1 2c       	mov	r12, r1
 7ec:	d1 2c       	mov	r13, r1
 7ee:	e1 2c       	mov	r14, r1
 7f0:	f1 2c       	mov	r15, r1
 7f2:	00 e0       	ldi	r16, 0x00	; 0
 7f4:	20 e0       	ldi	r18, 0x00	; 0
 7f6:	30 e0       	ldi	r19, 0x00	; 0
 7f8:	45 e5       	ldi	r20, 0x55	; 85
 7fa:	50 e0       	ldi	r21, 0x00	; 0
 7fc:	68 e0       	ldi	r22, 0x08	; 8
 7fe:	71 e0       	ldi	r23, 0x01	; 1
 800:	87 e8       	ldi	r24, 0x87	; 135
 802:	95 e0       	ldi	r25, 0x05	; 5
 804:	0e 94 e7 02 	call	0x5ce	; 0x5ce <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
 808:	81 30       	cpi	r24, 0x01	; 1
 80a:	49 f4       	brne	.+18     	; 0x81e <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 80c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
 80e:	80 93 f1 06 	sts	0x06F1, r24
		xTickCount = ( portTickType ) 0U;
 812:	10 92 f5 06 	sts	0x06F5, r1
 816:	10 92 f4 06 	sts	0x06F4, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 81a:	0e 94 92 01 	call	0x324	; 0x324 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
 81e:	0f 91       	pop	r16
 820:	ff 90       	pop	r15
 822:	ef 90       	pop	r14
 824:	df 90       	pop	r13
 826:	cf 90       	pop	r12
 828:	bf 90       	pop	r11
 82a:	af 90       	pop	r10
 82c:	08 95       	ret

0000082e <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 82e:	80 91 f0 06 	lds	r24, 0x06F0
 832:	8f 5f       	subi	r24, 0xFF	; 255
 834:	80 93 f0 06 	sts	0x06F0, r24
 838:	08 95       	ret

0000083a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 83a:	0f 93       	push	r16
 83c:	1f 93       	push	r17
 83e:	cf 93       	push	r28
 840:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 842:	80 91 f0 06 	lds	r24, 0x06F0
 846:	81 11       	cpse	r24, r1
 848:	b2 c0       	rjmp	.+356    	; 0x9ae <__stack+0xaf>
	{
		++xTickCount;
 84a:	80 91 f4 06 	lds	r24, 0x06F4
 84e:	90 91 f5 06 	lds	r25, 0x06F5
 852:	01 96       	adiw	r24, 0x01	; 1
 854:	90 93 f5 06 	sts	0x06F5, r25
 858:	80 93 f4 06 	sts	0x06F4, r24
		if( xTickCount == ( portTickType ) 0U )
 85c:	80 91 f4 06 	lds	r24, 0x06F4
 860:	90 91 f5 06 	lds	r25, 0x06F5
 864:	89 2b       	or	r24, r25
 866:	99 f5       	brne	.+102    	; 0x8ce <vTaskIncrementTick+0x94>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
 868:	80 91 0c 07 	lds	r24, 0x070C
 86c:	90 91 0d 07 	lds	r25, 0x070D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 870:	20 91 0a 07 	lds	r18, 0x070A
 874:	30 91 0b 07 	lds	r19, 0x070B
 878:	30 93 0d 07 	sts	0x070D, r19
 87c:	20 93 0c 07 	sts	0x070C, r18
			pxOverflowDelayedTaskList = pxTemp;
 880:	90 93 0b 07 	sts	0x070B, r25
 884:	80 93 0a 07 	sts	0x070A, r24
			xNumOfOverflows++;
 888:	80 91 ed 06 	lds	r24, 0x06ED
 88c:	8f 5f       	subi	r24, 0xFF	; 255
 88e:	80 93 ed 06 	sts	0x06ED, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 892:	e0 91 0c 07 	lds	r30, 0x070C
 896:	f0 91 0d 07 	lds	r31, 0x070D
 89a:	80 81       	ld	r24, Z
 89c:	81 11       	cpse	r24, r1
 89e:	07 c0       	rjmp	.+14     	; 0x8ae <vTaskIncrementTick+0x74>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8a0:	8f ef       	ldi	r24, 0xFF	; 255
 8a2:	9f ef       	ldi	r25, 0xFF	; 255
 8a4:	90 93 01 01 	sts	0x0101, r25
 8a8:	80 93 00 01 	sts	0x0100, r24
 8ac:	10 c0       	rjmp	.+32     	; 0x8ce <vTaskIncrementTick+0x94>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8ae:	e0 91 0c 07 	lds	r30, 0x070C
 8b2:	f0 91 0d 07 	lds	r31, 0x070D
 8b6:	05 80       	ldd	r0, Z+5	; 0x05
 8b8:	f6 81       	ldd	r31, Z+6	; 0x06
 8ba:	e0 2d       	mov	r30, r0
 8bc:	06 80       	ldd	r0, Z+6	; 0x06
 8be:	f7 81       	ldd	r31, Z+7	; 0x07
 8c0:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8c2:	82 81       	ldd	r24, Z+2	; 0x02
 8c4:	93 81       	ldd	r25, Z+3	; 0x03
 8c6:	90 93 01 01 	sts	0x0101, r25
 8ca:	80 93 00 01 	sts	0x0100, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8ce:	20 91 f4 06 	lds	r18, 0x06F4
 8d2:	30 91 f5 06 	lds	r19, 0x06F5
 8d6:	80 91 00 01 	lds	r24, 0x0100
 8da:	90 91 01 01 	lds	r25, 0x0101
 8de:	28 17       	cp	r18, r24
 8e0:	39 07       	cpc	r19, r25
 8e2:	08 f4       	brcc	.+2      	; 0x8e6 <vTaskIncrementTick+0xac>
 8e4:	69 c0       	rjmp	.+210    	; 0x9b8 <__stack+0xb9>
 8e6:	e0 91 0c 07 	lds	r30, 0x070C
 8ea:	f0 91 0d 07 	lds	r31, 0x070D
 8ee:	80 81       	ld	r24, Z
 8f0:	88 23       	and	r24, r24
 8f2:	99 f0       	breq	.+38     	; 0x91a <__stack+0x1b>
 8f4:	e0 91 0c 07 	lds	r30, 0x070C
 8f8:	f0 91 0d 07 	lds	r31, 0x070D
 8fc:	05 80       	ldd	r0, Z+5	; 0x05
 8fe:	f6 81       	ldd	r31, Z+6	; 0x06
 900:	e0 2d       	mov	r30, r0
 902:	c6 81       	ldd	r28, Z+6	; 0x06
 904:	d7 81       	ldd	r29, Z+7	; 0x07
 906:	8a 81       	ldd	r24, Y+2	; 0x02
 908:	9b 81       	ldd	r25, Y+3	; 0x03
 90a:	20 91 f4 06 	lds	r18, 0x06F4
 90e:	30 91 f5 06 	lds	r19, 0x06F5
 912:	28 17       	cp	r18, r24
 914:	39 07       	cpc	r19, r25
 916:	f8 f4       	brcc	.+62     	; 0x956 <__stack+0x57>
 918:	19 c0       	rjmp	.+50     	; 0x94c <__stack+0x4d>
 91a:	8f ef       	ldi	r24, 0xFF	; 255
 91c:	9f ef       	ldi	r25, 0xFF	; 255
 91e:	90 93 01 01 	sts	0x0101, r25
 922:	80 93 00 01 	sts	0x0100, r24
 926:	48 c0       	rjmp	.+144    	; 0x9b8 <__stack+0xb9>
 928:	e0 91 0c 07 	lds	r30, 0x070C
 92c:	f0 91 0d 07 	lds	r31, 0x070D
 930:	05 80       	ldd	r0, Z+5	; 0x05
 932:	f6 81       	ldd	r31, Z+6	; 0x06
 934:	e0 2d       	mov	r30, r0
 936:	c6 81       	ldd	r28, Z+6	; 0x06
 938:	d7 81       	ldd	r29, Z+7	; 0x07
 93a:	8a 81       	ldd	r24, Y+2	; 0x02
 93c:	9b 81       	ldd	r25, Y+3	; 0x03
 93e:	20 91 f4 06 	lds	r18, 0x06F4
 942:	30 91 f5 06 	lds	r19, 0x06F5
 946:	28 17       	cp	r18, r24
 948:	39 07       	cpc	r19, r25
 94a:	28 f4       	brcc	.+10     	; 0x956 <__stack+0x57>
 94c:	90 93 01 01 	sts	0x0101, r25
 950:	80 93 00 01 	sts	0x0100, r24
 954:	31 c0       	rjmp	.+98     	; 0x9b8 <__stack+0xb9>
 956:	8e 01       	movw	r16, r28
 958:	0e 5f       	subi	r16, 0xFE	; 254
 95a:	1f 4f       	sbci	r17, 0xFF	; 255
 95c:	c8 01       	movw	r24, r16
 95e:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
 962:	8c 89       	ldd	r24, Y+20	; 0x14
 964:	9d 89       	ldd	r25, Y+21	; 0x15
 966:	89 2b       	or	r24, r25
 968:	21 f0       	breq	.+8      	; 0x972 <__stack+0x73>
 96a:	ce 01       	movw	r24, r28
 96c:	0c 96       	adiw	r24, 0x0c	; 12
 96e:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
 972:	2e 89       	ldd	r18, Y+22	; 0x16
 974:	80 91 f2 06 	lds	r24, 0x06F2
 978:	82 17       	cp	r24, r18
 97a:	10 f4       	brcc	.+4      	; 0x980 <__stack+0x81>
 97c:	20 93 f2 06 	sts	0x06F2, r18
 980:	30 e0       	ldi	r19, 0x00	; 0
 982:	c9 01       	movw	r24, r18
 984:	88 0f       	add	r24, r24
 986:	99 1f       	adc	r25, r25
 988:	88 0f       	add	r24, r24
 98a:	99 1f       	adc	r25, r25
 98c:	88 0f       	add	r24, r24
 98e:	99 1f       	adc	r25, r25
 990:	82 0f       	add	r24, r18
 992:	93 1f       	adc	r25, r19
 994:	b8 01       	movw	r22, r16
 996:	80 5e       	subi	r24, 0xE0	; 224
 998:	98 4f       	sbci	r25, 0xF8	; 248
 99a:	0e 94 9e 00 	call	0x13c	; 0x13c <vListInsertEnd>
 99e:	e0 91 0c 07 	lds	r30, 0x070C
 9a2:	f0 91 0d 07 	lds	r31, 0x070D
 9a6:	80 81       	ld	r24, Z
 9a8:	81 11       	cpse	r24, r1
 9aa:	be cf       	rjmp	.-132    	; 0x928 <__stack+0x29>
 9ac:	b6 cf       	rjmp	.-148    	; 0x91a <__stack+0x1b>
	}
	else
	{
		++uxMissedTicks;
 9ae:	80 91 ef 06 	lds	r24, 0x06EF
 9b2:	8f 5f       	subi	r24, 0xFF	; 255
 9b4:	80 93 ef 06 	sts	0x06EF, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 9b8:	df 91       	pop	r29
 9ba:	cf 91       	pop	r28
 9bc:	1f 91       	pop	r17
 9be:	0f 91       	pop	r16
 9c0:	08 95       	ret

000009c2 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 9c2:	cf 92       	push	r12
 9c4:	df 92       	push	r13
 9c6:	ef 92       	push	r14
 9c8:	ff 92       	push	r15
 9ca:	0f 93       	push	r16
 9cc:	1f 93       	push	r17
 9ce:	cf 93       	push	r28
 9d0:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 9d2:	0f b6       	in	r0, 0x3f	; 63
 9d4:	f8 94       	cli
 9d6:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 9d8:	80 91 f0 06 	lds	r24, 0x06F0
 9dc:	81 50       	subi	r24, 0x01	; 1
 9de:	80 93 f0 06 	sts	0x06F0, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 9e2:	80 91 f0 06 	lds	r24, 0x06F0
 9e6:	81 11       	cpse	r24, r1
 9e8:	64 c0       	rjmp	.+200    	; 0xab2 <xTaskResumeAll+0xf0>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 9ea:	80 91 f6 06 	lds	r24, 0x06F6
 9ee:	81 11       	cpse	r24, r1
 9f0:	32 c0       	rjmp	.+100    	; 0xa56 <xTaskResumeAll+0x94>
 9f2:	62 c0       	rjmp	.+196    	; 0xab8 <xTaskResumeAll+0xf6>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 9f4:	d7 01       	movw	r26, r14
 9f6:	15 96       	adiw	r26, 0x05	; 5
 9f8:	ed 91       	ld	r30, X+
 9fa:	fc 91       	ld	r31, X
 9fc:	16 97       	sbiw	r26, 0x06	; 6
 9fe:	c6 81       	ldd	r28, Z+6	; 0x06
 a00:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
 a02:	ce 01       	movw	r24, r28
 a04:	0c 96       	adiw	r24, 0x0c	; 12
 a06:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
 a0a:	8e 01       	movw	r16, r28
 a0c:	0e 5f       	subi	r16, 0xFE	; 254
 a0e:	1f 4f       	sbci	r17, 0xFF	; 255
 a10:	c8 01       	movw	r24, r16
 a12:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 a16:	2e 89       	ldd	r18, Y+22	; 0x16
 a18:	80 91 f2 06 	lds	r24, 0x06F2
 a1c:	82 17       	cp	r24, r18
 a1e:	10 f4       	brcc	.+4      	; 0xa24 <xTaskResumeAll+0x62>
 a20:	20 93 f2 06 	sts	0x06F2, r18
 a24:	30 e0       	ldi	r19, 0x00	; 0
 a26:	c9 01       	movw	r24, r18
 a28:	88 0f       	add	r24, r24
 a2a:	99 1f       	adc	r25, r25
 a2c:	88 0f       	add	r24, r24
 a2e:	99 1f       	adc	r25, r25
 a30:	88 0f       	add	r24, r24
 a32:	99 1f       	adc	r25, r25
 a34:	82 0f       	add	r24, r18
 a36:	93 1f       	adc	r25, r19
 a38:	b8 01       	movw	r22, r16
 a3a:	80 5e       	subi	r24, 0xE0	; 224
 a3c:	98 4f       	sbci	r25, 0xF8	; 248
 a3e:	0e 94 9e 00 	call	0x13c	; 0x13c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 a42:	e0 91 44 07 	lds	r30, 0x0744
 a46:	f0 91 45 07 	lds	r31, 0x0745
 a4a:	9e 89       	ldd	r25, Y+22	; 0x16
 a4c:	86 89       	ldd	r24, Z+22	; 0x16
 a4e:	98 17       	cp	r25, r24
 a50:	58 f0       	brcs	.+22     	; 0xa68 <xTaskResumeAll+0xa6>
					{
						xYieldRequired = pdTRUE;
 a52:	dc 2c       	mov	r13, r12
 a54:	09 c0       	rjmp	.+18     	; 0xa68 <xTaskResumeAll+0xa6>
 a56:	d1 2c       	mov	r13, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 a58:	0f 2e       	mov	r0, r31
 a5a:	f1 e0       	ldi	r31, 0x01	; 1
 a5c:	ef 2e       	mov	r14, r31
 a5e:	f7 e0       	ldi	r31, 0x07	; 7
 a60:	ff 2e       	mov	r15, r31
 a62:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
 a64:	cc 24       	eor	r12, r12
 a66:	c3 94       	inc	r12
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 a68:	f7 01       	movw	r30, r14
 a6a:	80 81       	ld	r24, Z
 a6c:	81 11       	cpse	r24, r1
 a6e:	c2 cf       	rjmp	.-124    	; 0x9f4 <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 a70:	80 91 ef 06 	lds	r24, 0x06EF
 a74:	88 23       	and	r24, r24
 a76:	81 f0       	breq	.+32     	; 0xa98 <xTaskResumeAll+0xd6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 a78:	80 91 ef 06 	lds	r24, 0x06EF
 a7c:	88 23       	and	r24, r24
 a7e:	99 f0       	breq	.+38     	; 0xaa6 <xTaskResumeAll+0xe4>
					{
						vTaskIncrementTick();
 a80:	0e 94 1d 04 	call	0x83a	; 0x83a <vTaskIncrementTick>
						--uxMissedTicks;
 a84:	80 91 ef 06 	lds	r24, 0x06EF
 a88:	81 50       	subi	r24, 0x01	; 1
 a8a:	80 93 ef 06 	sts	0x06EF, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 a8e:	80 91 ef 06 	lds	r24, 0x06EF
 a92:	81 11       	cpse	r24, r1
 a94:	f5 cf       	rjmp	.-22     	; 0xa80 <xTaskResumeAll+0xbe>
 a96:	07 c0       	rjmp	.+14     	; 0xaa6 <xTaskResumeAll+0xe4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 a98:	f1 e0       	ldi	r31, 0x01	; 1
 a9a:	df 16       	cp	r13, r31
 a9c:	21 f0       	breq	.+8      	; 0xaa6 <xTaskResumeAll+0xe4>
 a9e:	80 91 ee 06 	lds	r24, 0x06EE
 aa2:	81 30       	cpi	r24, 0x01	; 1
 aa4:	41 f4       	brne	.+16     	; 0xab6 <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 aa6:	10 92 ee 06 	sts	0x06EE, r1
					portYIELD_WITHIN_API();
 aaa:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 aae:	81 e0       	ldi	r24, 0x01	; 1
 ab0:	03 c0       	rjmp	.+6      	; 0xab8 <xTaskResumeAll+0xf6>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 ab2:	80 e0       	ldi	r24, 0x00	; 0
 ab4:	01 c0       	rjmp	.+2      	; 0xab8 <xTaskResumeAll+0xf6>
 ab6:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 ab8:	0f 90       	pop	r0
 aba:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 abc:	df 91       	pop	r29
 abe:	cf 91       	pop	r28
 ac0:	1f 91       	pop	r17
 ac2:	0f 91       	pop	r16
 ac4:	ff 90       	pop	r15
 ac6:	ef 90       	pop	r14
 ac8:	df 90       	pop	r13
 aca:	cf 90       	pop	r12
 acc:	08 95       	ret

00000ace <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 ace:	cf 93       	push	r28
 ad0:	df 93       	push	r29
 ad2:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 ad4:	89 2b       	or	r24, r25
 ad6:	b1 f0       	breq	.+44     	; 0xb04 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
 ad8:	0e 94 17 04 	call	0x82e	; 0x82e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 adc:	80 91 f4 06 	lds	r24, 0x06F4
 ae0:	90 91 f5 06 	lds	r25, 0x06F5
 ae4:	c8 0f       	add	r28, r24
 ae6:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 ae8:	80 91 44 07 	lds	r24, 0x0744
 aec:	90 91 45 07 	lds	r25, 0x0745
 af0:	02 96       	adiw	r24, 0x02	; 2
 af2:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 af6:	ce 01       	movw	r24, r28
 af8:	0e 94 b0 02 	call	0x560	; 0x560 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 afc:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b00:	81 11       	cpse	r24, r1
 b02:	02 c0       	rjmp	.+4      	; 0xb08 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 b04:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
		}
	}
 b08:	df 91       	pop	r29
 b0a:	cf 91       	pop	r28
 b0c:	08 95       	ret

00000b0e <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b0e:	0f 2e       	mov	r0, r31
 b10:	f8 ef       	ldi	r31, 0xF8	; 248
 b12:	ef 2e       	mov	r14, r31
 b14:	f6 e0       	ldi	r31, 0x06	; 6
 b16:	ff 2e       	mov	r15, r31
 b18:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 b1a:	c0 e2       	ldi	r28, 0x20	; 32
 b1c:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 b1e:	80 91 f7 06 	lds	r24, 0x06F7
 b22:	88 23       	and	r24, r24
 b24:	51 f1       	breq	.+84     	; 0xb7a <prvIdleTask+0x6c>
		{
			vTaskSuspendAll();
 b26:	0e 94 17 04 	call	0x82e	; 0x82e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b2a:	d7 01       	movw	r26, r14
 b2c:	1c 91       	ld	r17, X
			xTaskResumeAll();
 b2e:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 b32:	11 23       	and	r17, r17
 b34:	11 f1       	breq	.+68     	; 0xb7a <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 b36:	0f b6       	in	r0, 0x3f	; 63
 b38:	f8 94       	cli
 b3a:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 b3c:	d7 01       	movw	r26, r14
 b3e:	15 96       	adiw	r26, 0x05	; 5
 b40:	ed 91       	ld	r30, X+
 b42:	fc 91       	ld	r31, X
 b44:	16 97       	sbiw	r26, 0x06	; 6
 b46:	06 81       	ldd	r16, Z+6	; 0x06
 b48:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 b4a:	c8 01       	movw	r24, r16
 b4c:	02 96       	adiw	r24, 0x02	; 2
 b4e:	0e 94 00 01 	call	0x200	; 0x200 <vListRemove>
					--uxCurrentNumberOfTasks;
 b52:	80 91 f6 06 	lds	r24, 0x06F6
 b56:	81 50       	subi	r24, 0x01	; 1
 b58:	80 93 f6 06 	sts	0x06F6, r24
					--uxTasksDeleted;
 b5c:	80 91 f7 06 	lds	r24, 0x06F7
 b60:	81 50       	subi	r24, 0x01	; 1
 b62:	80 93 f7 06 	sts	0x06F7, r24
				}
				taskEXIT_CRITICAL();
 b66:	0f 90       	pop	r0
 b68:	0f be       	out	0x3f, r0	; 63
		above the vPortFree() calls. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 b6a:	f8 01       	movw	r30, r16
 b6c:	87 89       	ldd	r24, Z+23	; 0x17
 b6e:	90 8d       	ldd	r25, Z+24	; 0x18
 b70:	0e 94 af 02 	call	0x55e	; 0x55e <vPortFree>
		vPortFree( pxTCB );
 b74:	c8 01       	movw	r24, r16
 b76:	0e 94 af 02 	call	0x55e	; 0x55e <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 b7a:	88 81       	ld	r24, Y
 b7c:	82 30       	cpi	r24, 0x02	; 2
 b7e:	10 f0       	brcs	.+4      	; 0xb84 <prvIdleTask+0x76>
			{
				taskYIELD();
 b80:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 b84:	0e 94 8b 00 	call	0x116	; 0x116 <vApplicationIdleHook>
		}
		#endif
	}
 b88:	ca cf       	rjmp	.-108    	; 0xb1e <prvIdleTask+0x10>

00000b8a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 b8a:	80 91 f0 06 	lds	r24, 0x06F0
 b8e:	81 11       	cpse	r24, r1
 b90:	13 c0       	rjmp	.+38     	; 0xbb8 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 b92:	80 91 f2 06 	lds	r24, 0x06F2
 b96:	90 e0       	ldi	r25, 0x00	; 0
 b98:	fc 01       	movw	r30, r24
 b9a:	ee 0f       	add	r30, r30
 b9c:	ff 1f       	adc	r31, r31
 b9e:	ee 0f       	add	r30, r30
 ba0:	ff 1f       	adc	r31, r31
 ba2:	ee 0f       	add	r30, r30
 ba4:	ff 1f       	adc	r31, r31
 ba6:	8e 0f       	add	r24, r30
 ba8:	9f 1f       	adc	r25, r31
 baa:	fc 01       	movw	r30, r24
 bac:	e0 5e       	subi	r30, 0xE0	; 224
 bae:	f8 4f       	sbci	r31, 0xF8	; 248
 bb0:	80 81       	ld	r24, Z
 bb2:	88 23       	and	r24, r24
 bb4:	29 f0       	breq	.+10     	; 0xbc0 <vTaskSwitchContext+0x36>
 bb6:	1b c0       	rjmp	.+54     	; 0xbee <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 bb8:	81 e0       	ldi	r24, 0x01	; 1
 bba:	80 93 ee 06 	sts	0x06EE, r24
 bbe:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 bc0:	80 91 f2 06 	lds	r24, 0x06F2
 bc4:	81 50       	subi	r24, 0x01	; 1
 bc6:	80 93 f2 06 	sts	0x06F2, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bca:	80 91 f2 06 	lds	r24, 0x06F2
 bce:	90 e0       	ldi	r25, 0x00	; 0
 bd0:	fc 01       	movw	r30, r24
 bd2:	ee 0f       	add	r30, r30
 bd4:	ff 1f       	adc	r31, r31
 bd6:	ee 0f       	add	r30, r30
 bd8:	ff 1f       	adc	r31, r31
 bda:	ee 0f       	add	r30, r30
 bdc:	ff 1f       	adc	r31, r31
 bde:	8e 0f       	add	r24, r30
 be0:	9f 1f       	adc	r25, r31
 be2:	fc 01       	movw	r30, r24
 be4:	e0 5e       	subi	r30, 0xE0	; 224
 be6:	f8 4f       	sbci	r31, 0xF8	; 248
 be8:	80 81       	ld	r24, Z
 bea:	88 23       	and	r24, r24
 bec:	49 f3       	breq	.-46     	; 0xbc0 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 bee:	80 91 f2 06 	lds	r24, 0x06F2
 bf2:	90 e0       	ldi	r25, 0x00	; 0
 bf4:	9c 01       	movw	r18, r24
 bf6:	22 0f       	add	r18, r18
 bf8:	33 1f       	adc	r19, r19
 bfa:	22 0f       	add	r18, r18
 bfc:	33 1f       	adc	r19, r19
 bfe:	22 0f       	add	r18, r18
 c00:	33 1f       	adc	r19, r19
 c02:	28 0f       	add	r18, r24
 c04:	39 1f       	adc	r19, r25
 c06:	d9 01       	movw	r26, r18
 c08:	a0 5e       	subi	r26, 0xE0	; 224
 c0a:	b8 4f       	sbci	r27, 0xF8	; 248
 c0c:	11 96       	adiw	r26, 0x01	; 1
 c0e:	ed 91       	ld	r30, X+
 c10:	fc 91       	ld	r31, X
 c12:	12 97       	sbiw	r26, 0x02	; 2
 c14:	02 80       	ldd	r0, Z+2	; 0x02
 c16:	f3 81       	ldd	r31, Z+3	; 0x03
 c18:	e0 2d       	mov	r30, r0
 c1a:	12 96       	adiw	r26, 0x02	; 2
 c1c:	fc 93       	st	X, r31
 c1e:	ee 93       	st	-X, r30
 c20:	11 97       	sbiw	r26, 0x01	; 1
 c22:	2d 5d       	subi	r18, 0xDD	; 221
 c24:	38 4f       	sbci	r19, 0xF8	; 248
 c26:	e2 17       	cp	r30, r18
 c28:	f3 07       	cpc	r31, r19
 c2a:	29 f4       	brne	.+10     	; 0xc36 <vTaskSwitchContext+0xac>
 c2c:	22 81       	ldd	r18, Z+2	; 0x02
 c2e:	33 81       	ldd	r19, Z+3	; 0x03
 c30:	fd 01       	movw	r30, r26
 c32:	32 83       	std	Z+2, r19	; 0x02
 c34:	21 83       	std	Z+1, r18	; 0x01
 c36:	fc 01       	movw	r30, r24
 c38:	ee 0f       	add	r30, r30
 c3a:	ff 1f       	adc	r31, r31
 c3c:	ee 0f       	add	r30, r30
 c3e:	ff 1f       	adc	r31, r31
 c40:	ee 0f       	add	r30, r30
 c42:	ff 1f       	adc	r31, r31
 c44:	8e 0f       	add	r24, r30
 c46:	9f 1f       	adc	r25, r31
 c48:	fc 01       	movw	r30, r24
 c4a:	e0 5e       	subi	r30, 0xE0	; 224
 c4c:	f8 4f       	sbci	r31, 0xF8	; 248
 c4e:	01 80       	ldd	r0, Z+1	; 0x01
 c50:	f2 81       	ldd	r31, Z+2	; 0x02
 c52:	e0 2d       	mov	r30, r0
 c54:	86 81       	ldd	r24, Z+6	; 0x06
 c56:	97 81       	ldd	r25, Z+7	; 0x07
 c58:	90 93 45 07 	sts	0x0745, r25
 c5c:	80 93 44 07 	sts	0x0744, r24
 c60:	08 95       	ret

00000c62 <memset>:
 c62:	dc 01       	movw	r26, r24
 c64:	01 c0       	rjmp	.+2      	; 0xc68 <memset+0x6>
 c66:	6d 93       	st	X+, r22
 c68:	41 50       	subi	r20, 0x01	; 1
 c6a:	50 40       	sbci	r21, 0x00	; 0
 c6c:	e0 f7       	brcc	.-8      	; 0xc66 <memset+0x4>
 c6e:	08 95       	ret

00000c70 <strncpy>:
 c70:	fb 01       	movw	r30, r22
 c72:	dc 01       	movw	r26, r24
 c74:	41 50       	subi	r20, 0x01	; 1
 c76:	50 40       	sbci	r21, 0x00	; 0
 c78:	48 f0       	brcs	.+18     	; 0xc8c <strncpy+0x1c>
 c7a:	01 90       	ld	r0, Z+
 c7c:	0d 92       	st	X+, r0
 c7e:	00 20       	and	r0, r0
 c80:	c9 f7       	brne	.-14     	; 0xc74 <strncpy+0x4>
 c82:	01 c0       	rjmp	.+2      	; 0xc86 <strncpy+0x16>
 c84:	1d 92       	st	X+, r1
 c86:	41 50       	subi	r20, 0x01	; 1
 c88:	50 40       	sbci	r21, 0x00	; 0
 c8a:	e0 f7       	brcc	.-8      	; 0xc84 <strncpy+0x14>
 c8c:	08 95       	ret

00000c8e <_exit>:
 c8e:	f8 94       	cli

00000c90 <__stop_program>:
 c90:	ff cf       	rjmp	.-2      	; 0xc90 <__stop_program>
